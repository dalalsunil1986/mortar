<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/mortar.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <a data-ice="repoURL" href="https://github.com/keystonejs/mortar" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/mortar.js~Context.html">Context</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isContext">isContext</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/mortar.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import _ from &apos;lodash&apos;;
import isClass from &apos;is-class&apos;;

// This regex detects the arguments portion of a function definition
// Thanks to Angular for the regex
const FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m;
const ERROR_PREFIX = &apos;[Trowel]&apos;;

/**
 * Mortar Context
 */
export default class Context {
	/**
	 *
	 * @param {Object} [module] node module
	 * @param {Context} [parent] parent context
	 */
	constructor(module, parent) {
		if (!parent &amp;&amp; module instanceof Context) {
			parent = module;
			module = parent.module;
		}

		/**
		 * The module object used to resolve lazy requires.
		 * @example
		 * import Context from &apos;mortar&apos;
		 * import assert from &apos;assert&apos;
		 * 
		 * const context = new Context(module);
		 * assert.strictEqual(module, context.module);
		 * context.require(&apos;./models/User&apos;).as.singleton(&apos;CurrentUser&apos;);
		 * context.retrieve(&apos;CurrentUser&apos;); //lazily required the User model relative to this module
		 * 
		 * @type {Object}
		 */
		this.module = module;
		/**
		 * The parent {@link Context} instance. Allows to set up hierarchical dependency injection containers.
		 * @example
		 * import Context from &apos;mortar&apos;
		 * import assert from &apos;assert&apos;
		 * const context = Context.create();
		 * const child = context.spawn();
		 * assert.strictEqual(child.parent, context);
		 * @type {Context}
		 */
		this.parent = parent;
		this._cache = new Map();
		/**
		 *
		 * @type {Map&lt;string,function&gt;}
		 */
		this.providers = new Map();
		for (let [name, configure] of Context.providers) {
			this.providers.set(name, configure(this));
		}
	}

	/**
	 * Registers a value to a provider for `key`.
	 * @example
	 * import Context from &apos;mortar&apos;
	 * import assert from &apos;assert&apos;
	 * const context = Context.create();
	 * function foo(){
	 * 	return {};
	 * }
	 * context.wire(foo).as.singleton(&apos;foo&apos;); // always returns the same object
	 * const f1 = context.retrieve(&apos;foo&apos;);
	 * const f2 = context.retrieve(&apos;foo&apos;);
	 * assert.strictEqual(f1, f2);
	 * @example
	 * import Context from &apos;mortar&apos;
	 * import assert from &apos;assert&apos;
	 * const context = Context.create();
	 * function foo(){
	 * 	return {};
	 * }
	 * context.wire(foo).as.producer(&apos;foo&apos;); // returns a new object every time we retrieve &quot;foo&quot;
	 * const f1 = context.retrieve(&apos;foo&apos;);
	 * const f2 = context.retrieve(&apos;foo&apos;);
	 * assert.notStrictEqual(f1, f2);
	 * @example
	 * import Context from &apos;mortar&apos;
	 * import assert from &apos;assert&apos;
	 * const context = Context.create();
	 * function foo(){
	 * 	return {};
	 * }
	 * context.wire(foo).as.value(&apos;foo&apos;); // returns the `foo` function
	 * const f = context.retrieve(&apos;foo&apos;);
	 * assert.strictEqual(f, foo);
	 * @param {*} subject - The value you want to register to the context
	 * @param {boolean} [constructable=false] - whether `new` should be used or the function should be called directly
	 * @throws {Error} when `subject` is `undefined`
	 * @throws {Error} when `key` already registered
	 * @throws {Error} when `key` not a String
	 * @returns {object}
	 * @property {function(key: string):Context} as.singleton - registers `subject` as a singleton provider for `key`
	 * @property {function(key: string):Context} as.producer - registers `subject` as a producer for `key`
	 * @property {function(key: string):Context} as.value - registers `subject` as a value for `key`
	 */
	wire(subject, constructable = false) {
		let as = {};
		for (let [name, provide] of this.providers) {
			as[name] = ((provide, name) =&gt; {
				return (key) =&gt; {
					if (typeof subject === &apos;undefined&apos;) {
						throw new Error(`${ERROR_PREFIX} Cannot wire &apos;undefined&apos; as a ${name}`);
					}
					if (this.has(key)) {
						throw new Error(`${ERROR_PREFIX} Wiring already exists for key &apos;${key}&apos;`);
					} else if (!_.isString(key) || key === &apos;&apos;) {
						throw new Error(`${ERROR_PREFIX} Cannot use ${key} as a key for wiring`);
					}
					this._cache.set(key, {subject: subject, provide: provide, constructable: constructable});
					return this;
				};
			})(provide, name);
		}
		as.as = as;
		return as;
	}

	/**
	 * Sets up lazy `require`ing of `id` when `key` is requested, relative to `module`.
	 * 
	 * See {@link Context#wire}
	 * @example
	 * import Context from &apos;mortar&apos;
	 * 
	 * const context = Context.create(module);
	 * context.require(&apos;./models/User&apos;).as.singleton(&apos;CurrentUser&apos;);
	 * // no code has been loaded yet
	 * context.retrieve(&apos;CurrentUser&apos;);
	 * // now &apos;./models/User&apos; is resolved and used to produce a singleton instance
	 * @param {String} id - the module id, e.g. &quot;lodash&quot; or &quot;./models/User&quot;
	 * @returns {object}
	 * @property {function(key: string):Context} as.singleton - registers `id` to be lazily required as a singleton provider for `key`
	 * @property {function(key: string):Context} as.producer - registers `id` to be lazily required as a producer for `key`
	 * @property {function(key: string):Context} as.value - registers `id` to be lazily required as a value for `key`
	 */
	require(id) {
		if (!this.module) {
			throw new Error(`${ERROR_PREFIX} Cannot require without providing a module to the constructor`);
		}
		const wrapped = ()=&gt; {
			return this.module.require(id);
		};
		wrapped.__mortar_wrapped = true;
		return this.wire(wrapped);
	}

	/**
	 * Unregisters `key`
	 * 
	 * @example
	 * import Context from &apos;mortar&apos;
	 * import assert from &apos;assert&apos;
	 * 
	 * const context = Context.create();
	 * context.wire(42).as.value(&apos;the answer to life, the universe and everything&apos;);
	 * assert.ok(context.has(&apos;the answer to life, the universe and everything&apos;));
	 * context.release(&apos;the answer to life, the universe and everything&apos;);
	 * assert.ok(! context.has(&apos;the answer to life, the universe and everything&apos;));
	 * @param {String} key - registration key
	 */
	release(key) {
		this._cache.delete(key);
	}

	/**
	 * Retrieves `subject`&apos;s dependencies and calls it.
	 * 
	 * @example
	 * import Context from &apos;mortar&apos;
	 * 
	 * function qux(){
	 *   return &apos;and thanks for all the fish!&apos;;
	 * }
	 * const context = Context.create();
	 * context
	 *   .wire(&apos;So long&apos;).as.value(&apos;foo&apos;)
	 *   .wire(qux).as.producer(&apos;qux&apos;);
	 * 
	 * context.resolve(function (foo, qux){
	 *   console.log(foo, qux); // outputs: So long, and thanks for all the fish!
	 * });
	 * @param {Function} subject
	 * @param {Boolean} [constructable=false] - whether `new` should be used or the function should be called directly
	 * @returns {*}
	 */
	resolve(subject, constructable = false) {
		return this.using(this.parent || {}).resolve(subject, constructable);
	}

	/**
	 * Allows you to override registered dependencies through another {@link Context} or mapping.
	 * @example
	 * import Context from &apos;mortar&apos;
	 * 
	 * const context = Context.create();
	 * context
	 *   .wire(&apos;So long&apos;).as.value(&apos;foo&apos;)
	 *   .wire(&apos;and thanks for all the fish!&apos;).as.value(&apos;qux&apos;);
	 * 
	 * const subject = function (foo, qux){
	 *   console.log(foo, qux);
	 * );
	 * 
	 * context.using({
	 *   foo: &apos;Adieu&apos;
	 * }).resolve(subject);
	 * //outputs: Adieu, and thanks for all the fish!
	 * @param {Context|Object} contextOrMap
	 * @returns {{resolve: resolve}}
	 */
	using(contextOrMap) {
		const context = this;
		if (_.isArray(contextOrMap) || (!_.isObject(contextOrMap) &amp;&amp; !isContext(contextOrMap))) {
			throw new Error(`${ERROR_PREFIX} Cannot use anything else but an object or Context 
				to override dependency resolutions`);
		} else if (_.isFunction(contextOrMap)) { //functions are objects too, i.e. won&apos;t branch into &quot;if&quot;
			contextOrMap = this.resolve(contextOrMap);
		}
		return {
			resolve: function(subject, constructable = false) {
				if (!_.isFunction(subject)) {
					throw new Error(`{ERROR_PREFIX} Cannot resolve anything else but a function`);
				}
				const dependencies = Context.getDependencies(subject);
				let resolved;
				if (isContext(contextOrMap)) {
					resolved = dependencies.map((dependency) =&gt; {
						return contextOrMap._retrieveWithFallback(dependency, context);
					});
				} else {
					resolved = dependencies.map((dependency) =&gt; {
						let value = contextOrMap[dependency];
						if (typeof value === &apos;undefined&apos;) {
							value = context.retrieve(dependency);
						}
						return value;
					});
				}
				return (constructable || isClass(subject)) ? new subject(...resolved) : subject(...resolved);
			}
		};
	}

	_retrieveWithFallback(key, fallback) {
		let config = this._cache.get(key);
		let value;
		if (!config) {
			if (fallback) {
				value = fallback.retrieve(key);
			}
		} else {
			if (_.get(config.subject, &apos;__mortar_wrapped&apos;, false)) {
				config.subject = config.subject();
			}
			value = config.provide(config.subject, config.constructable);
		}
		if (typeof value === &apos;undefined&apos;) {
			throw new Error(`${ERROR_PREFIX} wiring not found for key &apos;${key}&apos;`);
		}
		return value;
	}

	/**
	 * Retrieves the value registered to `key` using whatever rule it was wired with.
	 * @example
	 * import Context from &apos;mortar&apos;
	 * import assert from &apos;assert&apos;
	 * const context = Context.create();
	 * function foo(){
	 * 	return {};
	 * }
	 * context.wire(foo).as.singleton(&apos;foo&apos;); // always returns the same object
	 * const f1 = context.retrieve(&apos;foo&apos;);
	 * const f2 = context.retrieve(&apos;foo&apos;);
	 * assert.strictEqual(f1, f2);
	 * @param {!String} key
	 * @returns {*}
	 */
	retrieve(key) {
		return this._retrieveWithFallback(key, this.parent);
	}

	/**
	 * Checks whether a rule is registered to `key`.
	 * @example
	 * import Context from &apos;mortar&apos;
	 * import assert from &apos;assert&apos;
	 * const context = Context.create();
	 * assert.ok(! context.has(&apos;foo&apos;));
	 * context.wire(42).as.value(&apos;foo&apos;);
	 * assert.ok(context.has(&apos;foo&apos;));
	 * @param {!String} key
	 * @returns {boolean}
	 */
	has(key) {
		return this._cache.has(key);
	}

	/**
	 * Spawns a child context
	 * @example
	 * import Context from &apos;mortar&apos;
	 * import assert from &apos;assert&apos;
	 * const context = Context.create();
	 * const child = context.spawn();
	 * assert.strictEquals(child.parent, context);
	 * @returns {Context}
	 */
	spawn() {
		return Context.create(this.module, this);
	}

	/**
	 * Parses the dependencies of a function, by name.
	 * 
	 * @example
	 * import Context from &apos;mortar&apos;
	 * function foo( baz, qux, lodash ){}
	 * Context.getDependencies(foo); // [&apos;baz&apos;, &apos;qux&apos;, &apos;lodash&apos;]
	 * @param {!Function} subject
	 * @returns {Array.&lt;String&gt;}
	 */
	static getDependencies(subject) {
		if (!_.isFunction(subject)) {
			throw new Error(`${ERROR_PREFIX} cannot retrieve dependencies of anything else but a function`);
		}
		return Function.prototype.toString.call(subject)
			.match(FN_ARGS)[1]
			.split(&apos;,&apos;)
			.map((i) =&gt; i.trim())
			.filter((i)=&gt;i);
	}

	/**
	 * Factory method, creates a new context instance; thin wrapper for:
	 * ```js
	 * new Context(module, parent)
	 * ```
	 * See {@link Context#constructor}
	 * @param {Object} [module] node module
	 * @param {Context} [parent] parent context
	 * @returns {Context}
	 */
	static create(module, parent) {
		return new Context(module, parent);
	}

	/**
	 * Registers a provider to all instances. Either provide a named function, or an object with `name` and `configure` propterties
	 * @param {Function|Object} provider
	 * @param {!String} provider.name
	 * @param {Function} provider.configure
	 * @returns {Context}
	 */
	static register(provider) {
		if (!Context.providers) {
			Context.providers = new Map();
		} else if (Context.providers.has(provider.name)) {
			throw new Error(`${ERROR_PREFIX} provider already registered for &apos;${provider.name}&apos;`);
		}
		Context.providers.set(provider.name, provider.configure || provider);
		return Context;
	}
}

/**
 * Wrapper for 
 * ```js
 * subject instanceof Context
 * ```
 * @param {*} subject
 * @returns {boolean}
 */
export function isContext(subject) {
	return subject instanceof Context;
}

Context
	.register(function singleton(context) {
		return function getOrCreateInstance(factory, constructable=false) {
			if (typeof this.instance === &apos;undefined&apos;) {
				this.instance = context.resolve(factory, constructable);
			}
			return this.instance;
		};
	})
	.register(function value(/*context*/) {
		return (value) =&gt; value;
	})
	.register(function producer(context) {
		return (factory, constructable=false) =&gt; context.resolve(factory, constructable);
	})
;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.6)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
